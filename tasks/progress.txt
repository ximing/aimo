## Codebase Patterns
- MySQL configuration follows existing pattern in config.ts with typed interfaces
- Environment variables use sensible defaults (localhost:3306, root user, aimo database)
- **Drizzle config must use env vars directly (not import config.ts) to avoid module resolution issues**
- **Drizzle config schema path must point to dist/ folder (compiled JS), not src/ (TS source)**
- Connection pooling configured with max 10 connections by default
- Drizzle schemas: Use mysqlTable() with foreign keys via .references(), JSON columns via .$type<T>()
- VARCHAR key lengths: 191 for primary/foreign keys (MySQL utf8mb4 index limit), 255+ for other fields
- Timestamps: Use { mode: 'date', fsp: 3 } for millisecond precision to match LanceDB
- All schemas must be exported from index.ts for migration generation
- **Always build before generating migrations: pnpm build && pnpm migrate:generate**
- **App startup sequence: IOC → MySQL → Migrations → LanceDB → Scheduler → Express server**
- Shutdown sequence: Scheduler → MySQL → LanceDB (reverse order for clean shutdown)
- Database connection is a singleton accessed via getDatabase() from db/connection.ts
- Migration runner uses temporary connection separate from main pool

---

## 2026-03-01 19:53 - US-001
- Installed Drizzle ORM dependencies: drizzle-orm (^0.45.1), mysql2 (^3.18.2), drizzle-kit (^0.31.9 dev)
- Created drizzle.config.ts at apps/server/ with MySQL dialect and schema/migration paths
- Added MySQLConfig interface to config.ts with host, port, user, password, database, connectionLimit fields
- Added mysql property to Config interface and initialized in config object with env var defaults
- Updated .env.example with MySQL configuration section (MYSQL_HOST, MYSQL_PORT, MYSQL_USER, MYSQL_PASSWORD, MYSQL_DATABASE, MYSQL_CONNECTION_LIMIT)

**Files changed:**
- apps/server/package.json (dependencies)
- apps/server/drizzle.config.ts (created)
- apps/server/src/config/config.ts (added MySQLConfig interface and mysql config)
- .env.example (added MySQL section)

**Learnings for future iterations:**
- The project uses a centralized config.ts pattern - all new configuration should be added there with typed interfaces
- Environment variables should have sensible defaults for development (localhost, standard ports)
- The drizzle.config.ts references the main config to avoid duplicating connection details
- Typecheck must pass before committing - run `pnpm typecheck` from apps/server directory

---

## 2026-03-01 20:01 - US-002
- Created comprehensive Drizzle ORM schema definitions for all MySQL tables
- Implemented 11 table schemas in apps/server/src/db/schema/ directory:
  - users.ts: User accounts with indexes on email/phone
  - categories.ts: Memo categories with foreign key to users
  - tags.ts: Tags with usage count tracking
  - memos.ts: Memo content with JSON arrays for attachments/tagIds, foreign keys to users and categories
  - memo-relations.ts: Directed memo relations with composite unique index on (sourceMemoId, targetMemoId)
  - attachments.ts: File metadata (excluding multimodalEmbedding which goes to LanceDB)
  - ai-conversations.ts: AI conversation sessions
  - ai-messages.ts: Messages with sources stored as JSON array
  - daily-recommendations.ts: Daily recommendations with unique constraint on (uid, date)
  - push-rules.ts: Push notification rules with channels as JSON
  - table-migrations.ts: Migration tracking metadata
- Created index.ts to export all schemas
- All schemas include proper primary keys, foreign key constraints with cascade deletes, and indexes on frequently queried fields
- Used Drizzle's timestamp with defaultNow() and $onUpdate() for automatic timestamp management
- Exported type-safe types using $inferSelect and $inferInsert
- Typecheck passes successfully

**Files changed:**
- apps/server/src/db/schema/*.ts (12 files created: 11 table schemas + index)

**Learnings for future iterations:**
- Drizzle schemas use mysqlTable() function with column definitions and indexes
- Foreign keys defined using .references() with onDelete cascade/set null options
- JSON columns typed using .$type<T>() for type safety
- Composite indexes/unique constraints defined in second parameter of mysqlTable()
- Timestamps use { mode: 'date', fsp: 3 } for millisecond precision matching LanceDB
- VARCHAR lengths: 191 for keys (MySQL utf8mb4 index limit), 255 for emails/paths, larger for URLs
- Index naming convention: field_idx for single field, descriptive names for composite indexes
- All schemas must be exported from index.ts for Drizzle migration generation

---

## 2026-03-01 20:15 - US-003
- Created database connection service with connection pooling at apps/server/src/db/connection.ts
- Implemented initializeDatabase() function that creates MySQL connection pool and Drizzle instance
- Configured connection pool with max 10 connections (default), keepAlive enabled
- Exported getDatabase() singleton accessor with initialization check
- Implemented checkConnectionHealth() method that tests connection with ping
- Implemented getPoolStatus() method to retrieve pool configuration
- Implemented closeDatabase() for graceful shutdown with proper cleanup
- Integrated database initialization into app.ts startup sequence (after IOC, before LanceDB)
- Added health check on startup that throws error if MySQL connection fails
- Added MySQL pool shutdown to graceful shutdown handler (closes before LanceDB)
- Used `any` type for db variable to avoid TypeScript type compatibility issues with drizzle return type
- Typecheck passes successfully

**Files changed:**
- apps/server/src/db/connection.ts (created)
- apps/server/src/app.ts (added imports and initialization calls)

**Learnings for future iterations:**
- Database initialization should happen early in app startup, after IOC but before other services
- Connection health checks on startup help catch configuration issues early
- Shutdown sequence matters: close MySQL before LanceDB to ensure clean shutdown
- Drizzle's type system can be complex - using `any` for singleton instance is acceptable for pragmatism
- Connection pool logging helps with debugging connection issues in production
- The app follows a pattern: IOC → MySQL → LanceDB → Scheduler → Express server

---
## 2026-03-01 20:30 - US-004
- Generated initial Drizzle migration files using drizzle-kit generate
- Created migration 0000_tough_rhino.sql with all 11 tables (users, categories, tags, memos, memo_relations, attachments, ai_conversations, ai_messages, daily_recommendations, push_rules, table_migrations)
- Reviewed generated SQL: verified all tables, indexes, foreign keys, unique constraints, and timestamps are correct
- Created migration runner script at apps/server/src/db/migrate.ts with automatic migration execution
- Integrated migrations into app.ts startup sequence (runs after MySQL connection, before LanceDB initialization)
- Added pnpm scripts to package.json: migrate (manual migration), migrate:generate (generate new migrations), migrate:studio (Drizzle Studio)
- Modified drizzle.config.ts to use environment variables directly instead of importing config.ts (avoids module resolution issues)
- Changed schema path in drizzle.config.ts to point to dist/db/schema/index.js (compiled output) for proper module resolution
- Typecheck passes successfully

**Files changed:**
- apps/server/drizzle.config.ts (updated to use env vars and point to dist folder)
- apps/server/drizzle/0000_tough_rhino.sql (created - initial migration)
- apps/server/drizzle/meta/0000_snapshot.json (created - migration metadata)
- apps/server/drizzle/meta/_journal.json (created - migration journal)
- apps/server/src/db/migrate.ts (created - migration runner)
- apps/server/src/app.ts (added runMigrations() call in startup sequence)
- apps/server/package.json (added migrate scripts)

**Learnings for future iterations:**
- Drizzle-kit needs compiled JavaScript files, not TypeScript source files - point schema path to dist/ folder in drizzle.config.ts
- Drizzle config should use environment variables directly (with dotenv/config) to avoid circular dependencies with config.ts
- Migration runner should use a temporary connection separate from the main connection pool
- Migrations should run after MySQL connection but before LanceDB initialization to ensure schema exists
- The migrate() function from drizzle-orm/mysql2/migrator handles migration execution automatically
- Migration files are stored in drizzle/ folder with SQL and metadata (snapshot + journal)
- App startup sequence is now: IOC → MySQL → Migrations → LanceDB → Scheduler → Express server

---
## 2026-03-01 - US-005
- Refactored UserService to use Drizzle ORM instead of LanceDB
- Replaced all LanceDB queries with Drizzle queries using eq() operator
- Implemented all required methods: createUser(), getUserByUid(), getUserByEmail(), getUserByPhone(), updateUser()
- Removed LanceDB dependency from UserService constructor
- Fixed type compatibility issues between Drizzle (returns null) and DTOs (expect undefined)
- Updated user.controller.ts, memo.controller.ts, and auth-handler.ts to convert null to undefined using ?? operator
- Typecheck passes successfully

**Files changed:**
- apps/server/src/services/user.service.ts (refactored to use Drizzle)
- apps/server/src/controllers/v1/user.controller.ts (null to undefined conversion)
- apps/server/src/controllers/v1/memo.controller.ts (null to undefined conversion)
- apps/server/src/middlewares/auth-handler.ts (null to undefined conversion)

**Learnings for future iterations:**
- Drizzle nullable fields return `string | null`, but DTOs expect `string | undefined` - use `?? undefined` to convert
- Always use eq() from 'drizzle-orm' for equality comparisons instead of raw SQL strings
- Drizzle queries return arrays - check length > 0 and access [0] for single results
- When updating, remove the primary key from updates object to prevent errors
- After insert, fetch the created record to get auto-generated timestamps
- Pattern: getDatabase() → db.select().from(table).where(eq(table.field, value)).limit(1)
- Pattern: db.insert(table).values(data) for inserts
- Pattern: db.update(table).set(updates).where(eq(table.pk, id)) for updates

---

## 2026-03-01 - US-006
- Refactored CategoryService to use Drizzle ORM instead of LanceDB
- Replaced all LanceDB queries with Drizzle queries using eq(), and(), and sql operators
- Implemented all required methods: createCategory(), getCategoriesByUid(), getCategoryById(), getCategoryByName(), updateCategory(), deleteCategory()
- Removed clearCategoryFromMemos() method - foreign key constraint (onDelete: 'set null') handles this automatically
- Updated toCategoryDto() to convert Drizzle Date objects to timestamps and null to undefined
- Removed LanceDB dependency from CategoryService constructor
- Typecheck passes successfully

**Files changed:**
- apps/server/src/services/category.service.ts (refactored to use Drizzle)

**Learnings for future iterations:**
- Foreign key constraints with onDelete: 'set null' automatically handle cascading updates - no manual clearing needed
- Use sql`LOWER(${field}) = LOWER(${value})` for case-insensitive string comparisons in MySQL
- Drizzle timestamps are Date objects - convert to milliseconds with .getTime() for DTOs
- Pattern for updates: build partial object with only changed fields, then use db.update().set().where()
- Always fetch after insert/update to get auto-generated/updated timestamps from database
- The and() operator is useful for combining multiple WHERE conditions
---

## 2026-03-01 - US-007
- Refactored TagService to use Drizzle ORM instead of LanceDB
- Replaced all LanceDB queries with Drizzle queries using eq(), and(), and sql operators
- Implemented all required methods: createTag(), getTagsByUser(), getTagById(), getTagsByIds(), findTagByName(), updateTag(), deleteTag()
- Implemented atomic incrementUsageCount() and decrementUsageCount() using SQL expressions
- Used sql`${tags.usageCount} + 1` for atomic increment
- Used sql`GREATEST(0, ${tags.usageCount} - 1)` for atomic decrement (prevents negative values)
- Used sql`LOWER(${tags.name}) = LOWER(${normalizedName})` for case-insensitive tag name search
- Kept removeTagFromAllMemos() using LanceDB temporarily (will be updated when MemoService is migrated in US-010)
- Updated convertToTagDto() to convert Drizzle Date objects to timestamps and null to undefined
- Removed LanceDB dependency from TagService constructor
- Fixed import order to follow project conventions
- Typecheck passes successfully

**Files changed:**
- apps/server/src/services/tag.service.ts (refactored to use Drizzle)

**Learnings for future iterations:**
- Foreign key constraint tags.uid → users.uid was already defined in schema (onDelete: 'cascade')
- Use sql expressions for atomic updates: sql`${column} + 1` or sql`GREATEST(0, ${column} - 1)`
- GREATEST() function in MySQL prevents negative values in decrement operations
- For IN queries with dynamic arrays, use sql.raw() with proper escaping: sql`${column} IN ${sql.raw(`(${ids.map(id => `'${id}'`).join(',')})`)}`
- Case-insensitive search pattern: sql`LOWER(${column}) = LOWER(${value})`
- When other services still use LanceDB (like MemoService), use dynamic import to avoid circular dependencies
- Pattern: getDatabase() → db.select().from(table).where(and(eq(table.field1, value1), eq(table.field2, value2)))
- Pattern: db.insert(table).values(data) for inserts, then fetch to get auto-generated timestamps
- Pattern: db.update(table).set(updates).where(and(...conditions)) for updates
- Pattern: db.delete(table).where(and(...conditions)) for deletes
---

## 2026-03-01 - US-008
- Refactored MemoRelationService to use Drizzle ORM instead of LanceDB
- Replaced all LanceDB queries with Drizzle queries using eq() and and() operators
- Implemented all required methods: createRelation(), getRelatedMemos(), getBacklinks(), deleteRelation(), deleteRelationsBySourceMemo(), deleteRelationsByTargetMemo(), replaceRelations()
- Removed LanceDB dependency from MemoRelationService constructor
- Foreign key constraints (sourceMemoId → memos.memoId, targetMemoId → memos.memoId) and composite unique index were already defined in schema (from US-002)
- Converted Drizzle Date timestamp to milliseconds for MemoRelationRecord compatibility
- Typecheck passes successfully

**Files changed:**
- apps/server/src/services/memo-relation.service.ts (refactored to use Drizzle)

**Learnings for future iterations:**
- Foreign key constraints with onDelete: 'cascade' automatically handle cleanup when memos are deleted
- Composite unique index on (sourceMemoId, targetMemoId) prevents duplicate relations
- Pattern for multiple WHERE conditions: use and(eq(table.field1, value1), eq(table.field2, value2))
- Always fetch after insert to get auto-generated timestamps from database (createdAt)
- Drizzle returns Date objects for timestamps - convert to milliseconds with .getTime() for compatibility with existing types
- The replaceRelations() method uses existing helper methods (deleteRelationsBySourceMemo + createRelation) for clean implementation
---

## 2026-03-01 - US-016
- Created vector-only table schemas for LanceDB to separate embeddings from scalar data
- Added memoVectorsSchema with fields: memoId (string), embedding (dynamic-dim vector)
- Added attachmentVectorsSchema with fields: attachmentId (string), multimodalEmbedding (1024-dim vector)
- Exported new types: MemoVectorRecord and AttachmentVectorRecord
- Updated lancedb.ts to export new vector record types
- Embedding cache tables (embedding_cache, multimodal_embedding_cache) remain unchanged
- Typecheck passes successfully

**Files changed:**
- apps/server/src/models/db/schema.ts (added memoVectorsSchema, attachmentVectorsSchema, and type definitions)
- apps/server/src/sources/lancedb.ts (exported new vector record types)

**Learnings for future iterations:**
- Vector-only tables use minimal schemas with just ID + embedding fields for efficiency
- memo_vectors uses dynamic embedding dimensions from config (getEmbeddingDimensions())
- attachment_vectors uses fixed 1024-dim multimodal embeddings
- These schemas define the structure but table creation/migration happens in migration system
- Vector tables act as foreign key references to MySQL primary keys (memoId → memos.memoId, attachmentId → attachments.attachmentId)
- Indexes on vector fields will be created by the migration system (not in schema definition)
---
